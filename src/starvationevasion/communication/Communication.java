package starvationevasion.communication;

import starvationevasion.server.model.Type;

/**
 * The Communication class is meant to be implemented by a generic module
 * that will be responsible for both sending to and receiving data from
 * a server instance.
 *
 * For StarvationEvasion, an AI or UI client will instantiate an object
 * that implements Communication so that they are capable of maintaining contact
 * with the server. They themselves should not need to know anything about how
 * this is done or what happens when data is sent/received. They only need to know
 * how to pull data from the Communication module and send data through the module, which
 * should be a simple process for both.
 *
 * For any class implementing Communication, the following should be upheld ::
 *
 *      1) It should be entirely thread-safe. The hope will be that the server
 *         communicates with a Communication module as it needs to, and an AI or
 *         UI client will *also* be able to make requests of the Communication module
 *         whenever they want (Ex: as part of their main update loop). As a result,
 *         there should be no issues with any number of threads interfacing with the
 *         same Communication instance. This also takes much of the burden off of
 *         classes that use a Communication module to be thread-safe themselves.
 *
 *      2) For all incoming data from the server, the module is responsible for pre-processing
 *         that data and organizing it in such a way that the AI and UI clients that are
 *         depending upon the module can retrieve the data in a convenient manner. For example,
 *         if the server is sending an update about changes in world data, the module must
 *         keep a list of changes since the last time the AI/UI client requested the latest
 *         data.
 *
 * @author Justin Hall, George Boujaoude
 */
public interface Communication
{
  /**
   * This method takes an unspecified number of arguments. When called, these arguments form
   * the data that will be packaged up and sent over the network to the server.
   *
   * @param data Data to package and send to the server. Format for data ::
   *
   *             data[0] should always contain the current time (will be parsed as a double)
   *
   *             data[1] should contain the endpoint as a String (see starvationevasion.server.model.Endpoint)
   *                     - the server interprets each in a specific way
   *
   *             data[2] this is not specifically required, but depending on the Endpoint you used, it
   *                     may be needed - if the comment above the enum says "No Payload", data[2] isn't
   *                     needed
   *
   * @return true if the request was successful and false if not
   */
  boolean send(String ... data);

  /**
   * Note :: No responses should be pushed to their respective listeners until an external source
   *         (Ex: AI/UI client) requests that the Communication module do so. This avoids the issue
   *         of requiring these listeners to be thread-safe. See pushResponseEvents().
   *
   * This binds a response listener to a type. The type represents one of the possible responses that
   * can be generated by the server and pushed to a Communication module. These responses often
   * contain data from the server, so the listener itself will receive this data so that it can
   * push it to whoever needs it. For example, if the type was USER, it means that the server has just
   * sent an entire serialized User over the network (it can be cast directly to a User object).
   *
   * @param type type to listen for
   * @param listener listener to bind to - see starvationevasion.communication.ResponseListener
   */
  void setResponseListener(Type type, ResponseListener listener);

  /**
   * When this is called, the entire list of response events that were sent from the server since the last
   * time this was called will be pushed to their listeners (if no listener was bound, these events
   * should be shelved until a listener is bound).
   *
   * A good data structure to consider about for this is a FIFO list so that older events are processed
   * first, and newer commands are processed last in case they need to override/alter the outcome
   * of the older events.
   */
  void pushResponseEvents();

  /**
   * Disposes of this module. All existing threads should be shut down and data cleared out.
   *
   * The object is not meant to be used in any way after this is called.
   */
  void dispose();
}
